## 前后端交互

### Node

#### 知识点：

##### Node.js基础

1. Node是什么：

   Node是一个基于：Chrome V8引擎的JavaScript代码**运行环境**。

2. 运行环境：

   示例：Node能够运行JavaScript代码，Node就是JavaScript的运行环境。

3. Node的优点：

   * 使用JavaScript语法开发后端应用
   * 生态系统活跃，有大量开源库可以使用

4. Node.js运行环境安装：

   https://nodejs.org/en/

   nodejs是node的全称

5. node.js的组成：Node.js是由ECMAScript及Node 环境提供的一些附加API组成的，包括文件、网络、路径等等一些更加强大的 API。

6. Node.js基础语法

   所有ECMAScript语法在Node环境中都可以使用。在Node环境下执行代码，使用Node命令执行后缀为.js的文件即可

7. Node.js全局对象global

   在浏览器中全局对象是window，在Node中全局对象是global。

##### 模块加载及包

1. 模块化开发

   1. JavaScript开发的弊端

      文件依赖以及命名冲突

   2. 软件中的模块化开发

      一个功能就是一个模块，多个模块可以组成完整应用，抽离一个模块不会影响其他功能的运行。

   3. Node.js中的模块化开发规范
      * Node.js规定一个JavaScript文件就是一个模块，模块内部定义的变量和函数默认情况下在外部无法得到
      * 模块内部可以使用exports对象进行成员导出， 使用require方法导入其他模块

3. 系统模块

   1. 什么是系统模块

      Node运行环境提供的API. 

      因为这些API都是以模块化的方式进行开发的, 所以我们又称Node运行环境提供的API为系统模块

   2. 系统模块fs（文件操作系统）

      ```javascript
      const fs=require('fs');
      //读取文件内容
      //fs.readFile('文件路径/文件名称',['文件编码'], callback);
      fs.readFile('./01.helloworld.js', 'utf8', (err, doc) => {
      	// 如果文件读取出错err 是一个对象 包含错误信息
      	// 如果文件读取正确 err是 null
      	// doc 是文件读取的结果
      	console.log(err);
      	console.log(doc);
      });
      //写入文件代码
      //fs.writeFile('文件路径/文件名称', '数据', callback);
      const content = '<h3>正在使用fs.writeFile写入文件内容</h3>';
           fs.writeFile('../index.html', content, err => {
             if (err != null) { 
                 console.log(err);
                 return;
             }
             console.log('文件写入成功');
       });
      ```
      
   3. 系统模块path（路径操作）
   
      路径拼接语法
   
      ```javascript
      //导入path模块
      const path=require('path');
      //路径拼接path.join('路径','路径',.....)
      let finialPath=path.join('public','css','a.css');
      //输出的结果public\css\a.css
      console.log(finialPath);
      //使用__dirname获取当前文件所在的绝对路径
      let AbsolutePath=path.join(__dirname, 'public','css','a.css')
      ```
   
3. 第三方模块

   1. 什么是第三方模块？

      别人写好的、具有特定功能的、我们能直接使用的模块即第三方模块，由于第三方模块通常都是由多个文件组成并且被放置在一个文件夹中，所以又名包。

   2. 第三方模块的两种形式：

      * 以js文件的形式存在，提供实现项目具体功能的API接口
      * 以命令行工具形式存在，辅助项目开发（nodemon）

   3. 获取第三方模块

      * npmjs.com:第三模块的存储和分发仓库
      * npm：node的第三方模块管理工具
        1. 下载和卸载
           * npm install 模块名称
           * npm uninstall 模块名称
        2. 全局安装和本地安装
           * 命令行工具：全局安装
           * 库文件：本地安装

   4. 第三方模块：

      1. nodemon

         nodemon是一个命令行工具，辅助项目开发，没修改一次文件，会重新执行该文件。全局安装 npm i nodemon -g

      2. Gulp（待进一步学习）

         * Gulp基于node平台开发的前端构建工具，将机械化操作编写成任务, 想要执行机械化操作时执行一个命令行命令任务就能自动执行了，用机器代替手工，提高开发效率。
         * Gulp能做什么
           1. 项目上线，HTML、CSS、JS文件压缩合并
           2. 语法转换（es6、less ...）
           3. 公共文件抽离
           4. 修改文件浏览器自动刷新

         * Gulp使用:

           1. 使用npm install gulp下载gulp库文件
           2. 在项目根目录下建立gulpfile.js文件
           3. 重构项目的文件夹结构 src目录放置源代码文件 dist目录放置构建后文件
           4. 在gulpfile.js文件中编写任务.
           5. 在命令行工具中执行gulp任务

         * Gulp中提供的方法

           1. gulp.src()：获取任务要处理的文件
           2. gulp.dest()：输出文件
           3. gulp.task()：建立gulp任务
           4. gulp.watch()：监控文件的变化

           ```javascript
           const gulp = require('gulp');
             // 使用gulp.task()方法建立任务
            gulp.task('first', () => {
               // 获取要处理的文件
               gulp.src('./src/css/base.css') 
               // 将处理后的文件输出到dist目录
               .pipe(gulp.dest('./dist/css'));
            });
           ```

         * Gulp插件
           1. gulp-htmlmin ：html文件压缩
           2. gulp-csso ：压缩css
           3. gulp-babel ：JavaScript语法转化
           4. gulp-less: less语法转化
           5. gulp-uglify ：压缩混淆JavaScript
           6. gulp-file-include 公共文件包含
           7. browsersync 浏览器实时同步

4. Node.js中模块加载机制

   1. 模块查找规则-当模块拥有路径但没有后缀时
      * require方法根据模块路径查找模块，如果是完整路径，直接引入模块。
      * 如果模块后缀省略，先找同名JS文件再找同名JS文件夹
      * 如果找到了同名文件夹，找文件夹中的index.js
      * 如果文件夹中没有index.js就会去当前文件夹中的package.json文件中查找main选项中的入口文件
      * 如果找指定的入口文件不存在或者没有指定入口文件就会报错，模块没有被找到
   2. 模块查找规则-当模块没有路径且没有后缀时
      * Node.js会假设它是系统模块
      * Node.js会去node_modules文件夹中
      * 首先看是否有该名字的JS文件
      * 再看是否有该名字的文件夹
      * 如果是文件夹看里面是否有index.js
      * 如果没有index.js查看该文件夹中的package.json中的main选项确定模块入口文件
      * 否则找不到报错

5. package.json文件

   1. package.json文件的作用:项目描述文件，记录了当前项目信息，例如项目名称、版本、作者、github地址、当前项目依赖了哪些第三方模块等。使用npm init -y命令生成。
   2. 项目依赖:
      * 在项目的开发阶段和线上运营阶段，都需要依赖的第三方包，称为项目依赖
      * 使用npm install 包名命令下载的文件会默认被添加到 package.json 文件的 dependencies 字段中
   3. 开发依赖:
      * 在项目的开发阶段需要依赖，线上运营阶段不需要依赖的第三方包，称为开发依赖
      * 使用npm install 包名 --save-dev命令将包添加到package.json文件的devDependencies字段中
   4. package-lock.json文件的作用
      * 锁定包的版本，确保再次下载时不会因为包版本不同而产生问题
      *  加快下载速度，因为该文件中已经记录了项目所依赖第三方包的树状结构和包的下载地址，重新安装时只需下载即可，不需要做额外的工作。

##### 请求响应原理及HTTP协议

1. 服务器端基础

   1. 网站的组成

      * 网站应用程序主要分为两大部分：客户端和服务器端。
      * 客户端：在浏览器中运行的部分，就是用户看到并与之交互的界面程序。使用HTML、CSS、JavaScript构建。
      * 服务器端：在服务器中运行的部分，负责存储数据和处理应用逻辑；业务逻辑

   2. Node网站服务器 

      能够提供网站访问服务的机器就是网站服务器，它能够接收客户端的请求，能够对请求做出响应。

   3. IP地址

      互联网中设备的唯一标识。IP是Internet Protocol Address的简写，代表互联网协议地址

   4. 域名

      由于IP地址难于记忆，所以产生了域名的概念，所谓域名就是平时上网所使用的网址。

   5. 端口

      端口是计算机与外界通讯交流的出口，用来区分服务器电脑中提供的不同的服务。80端口提供web server

   6. URL

      * 统一资源定位符；是专为标识Internet网上资源位置而设的一种编址方式，我们平时所说的网页地址指的即是URL。

      * URL的组成：传输协议://服务器IP或域名:端口/资源所在位置标识

   7. 开发人员电脑

      客户端（浏览器）-服务器端（Node） 本地域名：localhost；127.0.01

2. 创建web服务器

3. HTTP协议

   1. HTTP:超文本传输协议（英文：HyperText Transfer Protocol，缩写：HTTP）规定了如何从网站服务器传输超文本到本地浏览器，它基于客户端服务器架构工作，是客户端（用户）和服务器端（网站）请求和应答的标准。

   2. 报文：在HTTP请求和响应的过程中传递的数据块就叫报文，包括要传送的数据和一些附加信息，并且要遵守规定好的格式。

      | 请求报文               |                |
      | ---------------------- | -------------- |
      | 请求方式               | post、get      |
      | 请求地址               | www.itcast.com |
      | Hello,请给我一个好消息 |                |

      | 响应报文        |           |
      | --------------- | --------- |
      | 内容类型        | text/html |
      | 内容长度        | 20        |
      | Hi,我就是好消息 |           |

   3. 请求报文

      * 请求方式：

        1. get 请求数据
        2. post 发送请求

      * 请求地址：

        ```javascript
        app.on('request', (req, res) => {
             req.headers  // 获取请求报文
             req.url      // 获取请求地址
             req.method   // 获取请求方法
        });
        ```

   4. 响应报文：

      * HTTP状态码

        1. 200 请求成功
        2. 404 请求的资源没有被找到
        3. 500 服务器端错误
        4. 400 客户端请求有语法错误

      * 内容类型

        1. text/html
        2. text/css
        3. application/javascript
        4. image/jpeg
        5. application/json

        ```javascript
        app.on('request', (req, res) => {
             // 设置响应报文
             res.writeHead(200, {
                 'Content-Type': 'text/html;charset=utf8‘
             });
         });
        ```

4. HTTP请求与响应处理

   1. 请求参数：客户端向服务器端发送请求时，有时需要携带一些客户信息，客户信息需要通过请求参数的形式传递到服务器端

   2. GET请求参数：参数被放置在浏览器地址栏中，例如：http://localhost:3000/`?name=zhangsan&age=20`

   3. 参数获取需要借助系统模块url，url模块用来处理url地址

      ```javascript
      //导入系统模块
      const http=require('http');
      //创建服务器
      const app=http.createServer();
      //当客户端发送请求
      app.on('requst',(req,res)=>{
          // 将url路径的各个部分解析出来并返回对象
          // true 代表将参数解析为对象格式
           let {query} = url.parse(req.url, true);
           console.log(query);
      })
       app.listen(3000);
      ```

   4. POST请求参数:参数被放置在请求体中进行传输;获取POST参数需要使用data事件和end事件；使用querystring系统模块将参数转换为对象格式（待进一步学习）
   5. 路由：是指客户端请求地址与服务器端程序代码的对应关系。简单的说，就是请求什么响应什么。
   6. 静态资源：服务器端不需要处理，可以直接响应给客户端的资源就是静态资源，例如CSS、JavaScript、image文件。
   7. 动态资源：相同的请求地址不同的响应资源，这种资源就是动态资源。

5. Node.js异步编程

   1. 同步API,异步API的区别？(获取返回值)

      同步API可以从返回值中拿到API执行的结果, 但是异步API是不可以的

      ```javascript
      // 同步
        function sum (n1, n2) { 
            return n1 + n2;
        } 
        const result = sum (10, 20);
       // 异步
        function getMsg () { 
            setTimeout(function () { 
                return { msg: 'Hello Node.js' }
            }, 2000);
        }
      const msg = getMsg ();
      ```

   2. 回调函数

      自已定义让别人去调用;回调函数就是一个被作为参数传递的函数;(回调函数是指 使用者自己定义一个函数,实现这个函数的程序内容,然后把这个函数(入口地址)作为参数传入别人(或系统)的函数中)

      ```javascript
      //getData函数定义
      function getData(callback){
      }
      //getData函数调用
      getData(()=>{   
      });
      ```

   3. Promise

      Promise出现的目的是解决Node.js异步编程中回调地狱的问题。

      ```javascript
      let promise = new Promise((resolve, reject) => {
          setTimeout(() => {
              if (true) {
                  resolve({name: '张三'})
              }else {
                  reject('失败了') 
              } 
          }, 2000);
      });
      promise.then(result => console.log(result); // {name: '张三'})
             .catch(error => console.log(error); // 失败了)
      
      ```

   4. 异步函数(待进一步学习)

      1. 异步函数是异步编程语法的终极解决方案，它可以让我们将异步代码写成同步的形式，让代码不再有回调函数嵌套，使代码变得清晰明了。

         ```javascript
         async function fn () {}
         const fn = async () => {};
         ```

      2. async关键字
         * 普通函数定义前加async关键字 普通函数变成异步函数
         * 异步函数默认返回promise对象
         * 在异步函数内部使用return关键字进行结果返回 结果会被包裹的promise对象中 return关键字代替了resolve方法
         * 在异步函数内部使用throw关键字抛出程序异常
         * 调用异步函数再链式调用then方法获取异步函数执行结果
         * 调用异步函数再链式调用catch方法获取异步函数执行的错误信息
      3. await关键字
         * await只能出现在异步函数中
         * await promise await后面只能写promise对象 写其他类型的API是不不可以的
         * await关键字可是暂停异步函数向下执行 直到promise返回结果

#### 关键代码

```javascript
//模块成员导出
//a.js
//在模块内部定义变量
let version=1.0;
const sayHai=(name)=>'您好，李华'
//向模块外部导出数据
//exports.version=version;
//exports.sayHai=sayHai;	
//模块成员导出的另一种方式
module.exports.version=version;
module.exports.sayHai=sayHai;
//exports是module.exports的别名(地址引用关系),导出对象最终以module.exports为准
```

```javascript
//模块成员导入
//b.js
//在b.js模块中导入模块
let b=require('./a');
//输出b模块中的version变量
console.log(b.version);
// 调用b模块中的sayHi方法 并输出其返回值
console.log(b.sayHi('李华'))

//导入模块是后缀可以省略
```

```javascript
//创建web服务器()
//引用系统模块
const http = require('http');
// 创建web服务器
const app = http.createServer();
// 当客户端发送请求的时候
app.on('request', (req, res) => {
	//  响应
	res.end('<h1>hi, user</h1>');
});
// 监听3000端口
app.listen(3000);
console.log('服务器已启动，监听3000端口，请访问 localhost:3000')
```

#### 问题

1. 服务器端-前端-后端-客户端之间的区别？

   （服务器端即后端？）

   * 前端：网页界面，通过浏览器实现页面交互的部分。
   * 后端：实现业务逻辑。
   * 客户端就是供用户直接操作使用的应用程序
   * 服务器端就是客户端请求数据时，用来处理请求，返回数据的程序。

2. 执行的顺序不太清楚？

   ```javascript
   function getMsg (callback) {
       setTimeout(function () {
           callback ({ msg: 'Hello Node.js' })
       }, 2000);
   }
   //让getMsg函数调用，自己是作为参数传递函数
   getMsg (function (msg) { 
       console.log(msg);
   });
   ```

   





