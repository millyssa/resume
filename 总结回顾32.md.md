# 总结回顾32

## 学习内容

[黑马前端基础班+就业班教程(第二部分)_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1gV411q7cz?p=75&spm_id_from=pageDriver)

## 回顾所学内容

1. 构造函数和原型

   * 创建对象的三种方式：

     1. 字面量方式
     2. new关键字
     3. 借用构造函数

   * new执行做的四件事情:

     1. 在内存中创建一个新的空对象。
     2. 让 this 指向这个新的对象。
     3. 执行构造函数里面的代码，给这个新对象添加属性和方法。
     4. 返回这个新对象（构造函数里面不需要 return ）。

   * 实例成员和静态成员：

     1. 成员：在构造函数中的属性和方法我们统称为成员

     2. 实例成员:

        * 构造函数内部通过this添加的成员,实例成员只能通过实例化的对象来访问

        * ```javascript
          //1.实例成员就是构造函数内部通过this添加的成员
          //实例成员只能通过实例化的对象来访问
                  console.log(ldh.uname);
                  ldh.sing();
          ```

     3. 静态成员：

        * 在构造函数本身上添加的成员,只能通过构造函数来访问,不能通过由构造函数创建的实例访问

        * ```javascript
           //2.静态成员 在构造函数本身上添加的成员 sex 就是静态成员
                  Star.sex = '男';
                  //静态成员只能通过构造函数访问
                  console.log(Star.sex);
                  //不能通过对象来访问
          ```

   * 构造函数原型对象prototype：
     1. 构造函数的弊端：存在浪费内存的问题。
     2. 原型：每一个构造函数都有一个 prototype 属性，指向另一个对象。这个 prototype 就是一个对象，这个对象的所有属性和方法，都会被构造函数所拥有。
     3. 原型的作用：资源共享。
   * 对象原型__proto__：
     1. 实例对象原型：实例对象有一个属性 __proto__ 指向构造函数的 prototype 原型对象。
     2. 实例对象原型__proto__和构造函数的prototype是等价的。
        方法的查找规则：首先先看对象身上是否有方法,如果有就执行这个对象上的方法，如果么没有这个方法,因为有__proto__ 的存在,就去构造函数原型对象prototype身上去查找方法。
   * 原型链：
     1. 每一个实例对象又有一个__proto__属性，指向的构造函数的原型对象，构造函数的原型对象也是一个对象，也有__proto__属性，这样一层一层往上找就形成了原型链。
   * 原型对象this指向：
     1. 构造函数中的this与原型对象的this指向的是new出来的实例对象

2. 继承

   * call方法的作用：
     1. call() 可以调用函数
     2. call() 可以改变这个函数的this指向

   * 利用父构造函数继承属性:

     1. 在子构造函数中通过 call() 把父类型的 this 指向子类型的 this ，这样就可以实现子类型继承父类型的属性

     2. ```javascript
           Father.call(this, uname, age);
        ```

   * 利用原型对象继承方法:
     1. Son.prototype = new Father();子构造函数的原型指向new出来的父构造函数。

3. ES5新增方法：

   * 数组的遍历((迭代))forEach

     ```javascript
      // forEach 迭代(遍历) 数组
             var arr = [1, 2, 3];
             var sum = 0;
             arr.forEach(function(value, index, array) {
                 console.log('每个数组元素' + value);
                 console.log('每个数组元素的索引号' + index);
                 console.log('数组本身' + array);
                 sum += value;
             })
             console.log(sum);
     ```

   *   筛选数组filter方法

     ```javascript
      var arr = [12, 66, 4, 88, 3, 7];
             var newArr = arr.filter(function(value, index) {
                 return value % 2 === 0;
             });
             console.log(newArr);
     ```

   * 找数组中是否有满足条件的元素some方法:返回值是布尔值

     ```javascript
      var arr = [10, 30, 4];
              var flag = arr.some(function(value) {
                  return value >= 20;
            		});
              console.log(flag);
     ```

   * 数组的forEach、some、filter区别

     1. forEach一般应用于数组的遍历,没有返回值
     2. some一般应用于查询数组中唯一的元素, 用some方法更合适,遇到return true 就是终止遍历 迭代效率更高,返回值是布尔值
     3. filter一般应用于数据的筛选,遇到return不会终止迭代,返回值是一个新数组

   * trim方法去除字符串两侧空格

     1. trim()  方法会从一个字符串的两端删除空白字符。
     2. trim() 方法并不影响原字符串本身，它返回的是一个新的字符串

   * Object.keys获取对象属性名

     1. 对象方法Object.keys() 方法返回一个对象的所有的属性名并保存到一个数组中

        ```javascript
        // 用于获取对象自身所有的属性
                var obj = {
                    id: 1,
                    pname: '小米',
                    price: 1999,
                    num: 2000
                };
                var arr = Object.keys(obj);
                console.log(arr);
        ```

   * Object.defineProperty() 方法：

     1. Object.defineProperty()定义新属性或修改原有的属性

        ```javascript
        //参数一是当前设置的对象。
        //参数二是需定义或修改的属性的名字。
        //参数三是一个对象。
        Object.defineProperty(obj, 'num', {
                    value: 1000,
                    enumerable: true
                });
        ```

     2. Object.defineProperty()设置或者修改对象属性

        ```javascript
        //参数一是当前设置的对象。
        //参数二是需定义或修改的属性的名字。
        //参数三是一个对象,对象中有多个属性。
        //属性一是value:: 设置属性的值
        //属性二是writable: false/true;如果值为false 不允许修改这个属性值 默认值也是false
        //属性三是enumerable: false/true;如果值为false 则不允许遍历, 默认的值是 false
        //属性四是configurable: false/true;如果为false 则不允许删除这个属性 不允许在修改第三个参数里面的特性 默认为false
        
        ```

4. 函数进阶：

   * 函数的定义方式：

     ```javascript
     //  函数的定义方式
     
             // 1. 自定义函数(命名函数) 
     
             function fn() {};
     
             // 2. 函数表达式 (匿名函数)
     
             var fun = function() {};
     
     
             // 3. 利用 new Function('参数1','参数2', '函数体');
     
             var f = new Function('a', 'b', 'console.log(a + b)');
             f(1, 2);
             // 4. 所有函数都是 Function 的实例(对象)
             console.dir(f);
             // 5. 函数也属于对象
             console.log(f instanceof Object);
     ```

   * 函数的调用方式：

     ```javascript
     // 函数的调用方式
     
             // 1. 普通函数
             function fn() {
                 console.log('人生的巅峰');
     
             }
             // fn();   fn.call()
             // 2. 对象的方法
             var o = {
                 sayHi: function() {
                     console.log('人生的巅峰');
     
                 }
             }
             o.sayHi();
             // 3. 构造函数
             function Star() {};
             new Star();
             // 4. 绑定事件函数
             // btn.onclick = function() {};   // 点击了按钮就可以调用这个函数
             // 5. 定时器函数
             // setInterval(function() {}, 1000);  这个函数是定时器自动1秒钟调用一次
             // 6. 立即执行函数
             (function() {
                 console.log('人生的巅峰');
             })();
             // 立即执行函数是自动调用
     ```

   * this指向：

     1. 普通函数 this 指向window

     2. 对象的方法 this指向的是对象 

     3. 构造函数 this 指向 构造函数new出来的实例对象

     4. 绑定事件函数 this 指向的是函数的调用者

     5. 定时器函数 this 指向的是window

     6. 立即执行函数 this指向的是window

     7. 改变this指向的三个方法：

        | 方法    | 描述                                                         |
        | :------ | ------------------------------------------------------------ |
        | call()  | call可以改变函数内部的this指向,参数的传递使用逗号隔开        |
        | apply() | apply可以改变this指向,并立即调用函数,使用apply方法传递参数使用数组传递 |
        | bind()  | bind不会调用原来的函数   可以改变原来函数内部的this 指向,返回的是原函数改变this之后产生的新函数 |

        * 三者的区别：
          1. 相同点：都可以改变this指向
          2. 不同点：
             * call 和 apply  会调用函数, 并且改变函数内部this指向
             * call传递参数使用逗号隔开传递,apply传递参数使用数组传递
             * bind不会调用函数
             * 应用场景:
               1. call 经常做继承
               2. apply 经常跟数组有关系.  比如借助于数学对象实现数组最大值最小值
               3. bind 不调用函数,但是还想改变this指向. 比如改变定时器内部的this指向

   * 严格模式：

     1. 开启严格模式：使用‘use strict’

     2. 严格模式的特点：

        1. 变量：

           * 在正常模式中,如果一个变量没有声明就赋值,默认是全局变量.严格模式禁止这种用法,变量都必须先用var命令声明,然后再使用
           * 严禁删除已经声明变量。例如，delete x; 语法是错误的

        2. this 指向问题：

           * 严格模式下全局作用域中函数中的 this 是 undefined
           * 严格模式下,如果 构造函数不加new调用, this 指向的是undefined 如果赋值,会报错
           * new 实例化的构造函数指向创建的对象实例。
           * 定时器 this 还是指向 window 
           * 事件、对象还是指向调用者

        3. 函数变化

           * 函数不能有重名的参数

           * 函数必须声明在最前面.新版本的JavaScript会引入“块级作用域”（ ES6 中已引入）为了与新版本接轨，不允许在非函数的代码块内声明函数

   * 高阶函数：

     1. 高阶函数是对其他函数进行操作的函数，它接收函数作为参数或将函数作为返回值输出。

   * 闭包：

     1. 闭包（closure）:一个作用域可以访问另一个函数内部的变量的函数
     2. 闭包的主要作用: 延伸了变量的作用范围。

   * 递归：

     1. 函数内部自己调用自己
     2. 递归需要有结束条件，不然会使栈溢出。

     
     

   
