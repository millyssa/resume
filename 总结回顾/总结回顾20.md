# 总结回顾20

## 学习内容

[JavaScript基础语法-dom-bom-js-es6新语法-jQuery-数据可视化echarts黑马pink老师前端入门基础视频教程(500多集)持续_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1Sy4y1C7ha?p=287)

## 回顾所学内容

1. 脚本调用策略

   * 解决Script在调用时受阻的策略。

   解决方式：

   * 对于内部事件监听器,即HTML文档加载完毕，解释完毕才会触发事件。
   * 对于外部可以使用异步处理
   * 旧方法就是把脚本元素放在文档体的低端，这样脚本就可以在 HTML 解析完毕后加载了。此方案的问题是

   async和defer

   * 如果脚本无需等待页面解析，且无依赖独立运行，那么应使用async。

     ```javascript
     <script src='main.js' async></script>
     ```

     

   * 如果脚本需要等待页面解析，且依赖于其它脚本，调用这些脚本时应使用defer，将关联的脚本按所需顺序置于 HTML 中。

   * 注意：“外部”示例中 async 属性可以解决调用顺序问题，而 async 只能用于外部脚本，因此不适用于“内部”示例。

2. 多态：用来描述多个对象拥有实现共同方法的能力。

3. 原型对象：

   * 对象以其原型为模板、从原型继承方法和属性。

   * 原型链：是一种原型对象中有原型，并从中继承方法和属性，一层一层、以此类推。

   * prototype属性：继承成员被定义的地方

     原型对象是一个内部对象，应当使用_proto__访问）。prototype属性包含（指向）一个对象，你在这个对象中定义需要被继承的成员。 

   * constructor属性:获得对象实例的构造器名字

4. JSON

   1. JSON是一种按照JavaScript对象语法的数据格式。

   2. JSON可以作为一个对象或者字符串存在，前者用于解读 JSON 中的数据，后者用于通过网络传输 JSON 数据
   3. JSON 对象就是基于 JavaScript 对象

5. 事件高级

   1. 注册事件有两种方法：
      * 传统注册事件：利用on开头的事件，注册事件具有唯一性，同一个元素同一个事件只能设置一个处理函数。
      * 方法监听注册方式：ie9之前不支持此方法，可使用attachEvent代替，addEventListen()它是一个方法t同一个元素同一个事件可以注册多个监听器。

   2. 删除事件

      * 传统注册方式：eventTarget.onclick=null
      * 方法监听注册方式:
        1. eventTarget.removeEventListener(type,listener[,useCapture]);
        2. eventTarget.removeEventListener(eventNameWithOn,callback);

   3. 事件流：描述的是从页面中接收事件的顺序。

      1. DOM事件流：在元素节点之间按照特定的顺序传播。

      2. 事件流的三个阶段
         * 捕获阶段
         * 当前目标阶段
         * 冒泡阶段
      3. js代码中只能执行捕获或者冒泡其中一个阶段
      4. onclick和attachEvent只能得到冒泡阶段
      5. attachEventListener(type,listener[,useCapture])z中的第三个参数为true，表示事件捕获阶段，如果是false（默认是false）就是在冒泡阶段
      6. 有些事件没有冒泡onblur，onfocus

   4. 事件对象

      1. 事件发生后，事件相关的一系列信息数据集合都放到这个对象里面。这个对象就是事件对象。

      2. 事件对象的常见属性和方法

         | 事件对象属性方法  |                               |
         | ----------------- | ----------------------------- |
         | e.target          | 返回触发事件的对象 标准       |
         | e.srcElement      | 返回触发事件的对象 ie6-8使用  |
         | e.preventDefault  | 阻止默认事件 比如不让链接跳转 |
         | e.stopPropagation | 阻止冒泡                      |

   5. 事件委托：

      1. 原理：不是每个子节点单独设置事件监听器，而是事件监听器设置在父节点上，然后利用冒泡原理影响设置每个节点。
      2. 作用：我们只能操作一次DOM,提高了程序的性能

   6. 鼠标事件：

      | 鼠标事件对象        | 说明                                        |
      | ------------------- | ------------------------------------------- |
      | e.clientX,e.clientY | 返回鼠标相对于浏览器窗口可视区的x和y坐标    |
      | e.pageX,e.pageY     | 返回鼠标相对于文档页面的的x和y坐标 ie9+支持 |
      | e.screenX,e.screenY | 返回鼠标相对于电脑屏幕的x和y坐标            |

   7. 键盘事件

      | 键盘事件   |                                                     |
      | ---------- | --------------------------------------------------- |
      | onkeyup    | 某个键盘按键松开时 触发                             |
      | onkeydown  | 某个键盘按键按下时 触发                             |
      | onkeypress | 某个键盘按键按下时 触发 但是不识别ctrl shift 箭头等 |

      * 三个的执行顺序是 onkeydown->keypress->keyup
      * 键盘事件对象
        1. keyCode：返回该键的ASCII码
        2. onkeydown,keyup不区分大小写，keypress区分大小写

   8. BOM

      1. BOM：是浏览器对象模型提供了独立于内容而与浏览器窗口进行交互的对象。
      2. window对象是浏览器的顶级对象
      3. 常见加载事件
         * window.onload:加载事件，当文档内容加载完毕会触发该事件
         * DOMContentLoaded事件触发时，仅当DOM加载完成，不包括样式表，图片等等，执行效率更高。ie9以上支持
      4. 调整窗口大小事件
         1. window.resize:只要窗口大小发生像素变化，就会触发这个事件。

      5. 定时器

         * setTimeout()定时器

           该方法在定时器到期后执行调用函数。调用函数

         * setInterval定时器

           该方法重复调用一个函数，每隔这个事件，就去调用一次回调函数

         * requstAnimationFrame

           该方法是一个专门的循环函数，旨在浏览器中高效运行动画。它允许动画以适当帧率运行，不管其运行的环境如何。解决了一些setInterval的问题。

         * 清除定时器

           1. clearTimeout
           2. clearInterval

   9. 回调函数

      回头调用这个函数，上一件事干完，再回头在调用这个函数。

   10. this指向问题

   1. 全局作用域或者普通函数中this指向全局对象window
   2. 方法调用中谁调用this指向谁
   3. 构造函数中this指向构造函数实例。

   11. JS同步和异步

       * JS是单线程，单线程意味着任务需要排队，前一个任务结束，后一个任务才开始。
       * 同步就是前一个任务结束，后一个任务才开始
       * 异步就是 同时执行多个任务
       * 同步任务都在主线程上执行，形成执行栈
       * 异步任务是通过回调函数实现。相关回调函数调加到任务队列中
       * 执行机制：先执行栈中的同步任务，将异步任务放入队列中，一旦同步任务执行完毕，就依次执行任务队列中的异步任务。
       * 事件循环：主线程不断的重复获得任务，执行任务，再获得任务，再执行的机制。
       * promises新派的异步代码，fetch().
       * promise与callback本质上是一个返回的对象，promises将回调函数附加到该对象上，而不必将回调作为参数传递给另一个函数。

   12. location对象

       地址对象

       | location对象属性  | 返回值                               |
       | ----------------- | ------------------------------------ |
       | location.href     | 获取或者设置 整个url                 |
       | location.host     | 返回主机（域名）                     |
       | location.port     | 返回端口                             |
       | location.pathname | 返回路径                             |
       | location.search   | 返回参数                             |
       | location.hash     | 返回片段 #后面的内容 常见于链接 锚点 |

   13.navigator对象：包含有关浏览器的信息，最常用的是userAgent,返回可以返回由客户机发送服务器的user-agent代理人头部的值。

   14. history对象

       | history对象 |              |
       | ----------- | ------------ |
       | back（）    | 可以后退功能 |
       | forward（） | 前进功能     |
       | go（参数）  | 前进后退功能 |

## 学习中遇到的问题

1. 脚本调用策略中的使用异步async和BOM中的异步操作之间的区别。





